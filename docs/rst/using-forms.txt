Using forms
===========

Form behaviour
--------------
A very common pattern of web applications, is to write HTML forms. Konstrukt provides a standard mechanism for making it simple and fast to whip up a form, with the ``k_FormBehaviour`` component. As with all abstractions, this particular component restrict your freedom as a developer a bit. There may be situations, where the standard form behaviour doesn't really fit your needs. In these cases, you shouldn't try to shoehorn your application into the framework. That said, k_FormBehaviour is highly configurable, and can be extended in different directions.

Taking a step back, forms are essentially just controllers which displays the HTML markup for a ``<form>`` on a GET-request, and process the contents on a POST request. Further, most forms will do some filtering on input, and some sort of validation, before processing. Since validation may fail, forms should have the ability to re-populate and re-display, displaying validation errors. To prevent the dreaded 'broken-back-button' problem, most forms are programmed to re-direct to itself, following a POST request (Also known as the [[PRG-pattern|http://www.theserverside.com/tt/articles/article.tss?l=RedirectAfterPost]]. All of these features are implemented in ``k_FormBehaviour``.

Creating a form
---------------
To promote code reuse and decoupling, ``k_FormBehvaiour`` is implemented as a component, rather than an abstract controller. This means that you use it in your code through composition, rather then inheritance. The syntax is a bit more verbose, but offers greater flexibility.

Implementing a form, is a matter of instantiating a ``k_FormBehaviour``, and delegating control to it. The following example shows how:

::
class MyForm extends k_Controller
{
  function __construct(k_iContext $context, $name) {
    parent::__construct($context, $name);
    $this->form = new k_FormBehaviour($this, "templates/myform.tpl.php");
  }
\
  function execute() {
    return $this->form->execute();
  }
}

This rudimentary example will create a form -- sort of -- but the form won't have any fields, and it isn't really useful for a couple of other reasons.

Form descriptor
---------------

Forms are meant to gather information from the user, and information is broken down into a number of fields. Each field is kept in a separate variable, and is presented in a distinct input control; Often represented by a single HTML element, such as an ``<input>`` tag. The form behaviour needs to know which fields the form contains. You provide this information by setting the ``$descriptors`` property. This is an array of field descriptors. Each descriptor is itself an associative array with certain configuration settings, of which "name" is the most important (And only one required).

Let's assume that we want to create a sign-up form for our web site. The form should contain an email address and a password field. This is how the descriptor could look like:

::
$this->form->descriptors = Array(
  Array("name" => "email"),
  Array("name" => "password"),
);

###Default values
As mentioned, "name" isn't the only value that a field descriptor can have. Sometimes you want to pre-populate fields with reasonable starting values. In this example, let's assume that the form will contain another field "country", which is supposed to be used to tell which country the user is from. Most of our users are from Uzbekistan, so it's a reasonable value to default to. We can add a default value this way:

::
$this->form->descriptors = Array(
...
  Array("name" => "country", "default" => "Uzbekistan"),
);

::note
Providing default values like this, is convenient for constants. Sometimes you need to calculate the values at runtime. For this, you can implement ``getDefaultValues()`` on the controller. The form behaviour will see this and call back and use that data instead.

###Filters
Another option of the field descriptor, is the ability to supply one or more filters for the input data. For example, if you wanted the email to be all lowercase:
::
$this->form->descriptors = Array(
  Array("name" => "email", "filters" => Array("strtolower")),
...
);

A common trick, is to add ``trim()`` as a filter, to prevent users from acidentially typing a leading or trailing white space.

Template
--------

The next thing we need to do, is to provide a template. As you can see in the example above, we have told the form to use the file ``templates/myform.tpl.php`` as a template. For starters, let's use the following:

::html
<form <?php echo $this->getFormProperties(); ?>>
<?php foreach ($this->fields as $field) : ?>
<p>
<label for="<?php echo $field->id; ?>"><?php echo $field->name; ?></label>
<?php echo $field; ?>
<?php foreach ($field->messages as $error) : ?>
<span><?php echo $error; ?></span>
<?php endforeach; ?>
\
</p>
<?php endforeach; ?>
\
<input type="submit" />
</form>

This is basically some HTML, with a little bit of embedded PHP. While this will get us a basic form, there are a few tricks, you can pull to beef up the template a bit. Let's go through the possibilities:

``$this`` refers to the rendering component -- in this case, the ``k_FormBehaviour`` object. The most important property here, is ``$this->fields``. This property is traversable, which means that it can be looped over with ``foreach`` as in this example, but sometimes you need to present specific fields differently. You can get a specific property by its name, using ``$this->fields->foo``, where "foo" is the name of the field. In cases where you refer a single field explicitly in this way, you will still want to be able to loop over the remaining fields. You can use ``getExclusive()`` to get all fields, except the ones explicitly named. ``getExclusive()`` takes variable number of arguments, so to get all fields, except "foo" and "bar", you could use:

::html
<?php foreach ($this->fields->getExclusive("foo", "bar") as $field) : ?>

If you prefer, you can also call it with one argument, which is an array of names. It depends on the situation, which method is the most practical.

The object returned by these methods, is an instance of ``k_Field``.

###Customising form rendering

The field belongs to ``$this->fields``, which is a ``k_FieldCollection``. In the above example, we have simply been echo'ing the field. This implicitly calls the fields ``render()`` method. This calls back to the form behaviour. If the hosting component implements ``renderField()``, rendering is delegated to this; Otherwise, a default ``<input type=text />`` is returned. This pipeline allows you to reuse the same form template, in forms shich differs only in which fields, and which input-widget is used to edit it.

::
class MyForm extends k_Controller
{
  function renderField($field) {
    switch ($field->name) {
      case 'pass':
        return "<input type='password' name='pass' />";
      case 'image':
        return "<input type='file' name='image' />";
      default:
        return "<input type='text' name='".$field->name."' value='".htmlspecialchars($field->value)."' />";
    }
  }
}

You may find it practical to create a collection of helper function for generating standard widgets in ``renderField()``.

Required methods
----------------

Now, as we have the rendering of the HTML representation of our form in place, let's take a look at the logic within. ``k_FormBehaviour`` expects that the context controller (``MyForm``) implements a method ``validate()``, which will be invoked when the form is being submitted. If no such method is implemented, the form will generate a runtime error, when it's posted (submitted). To begin with, let's provide a dummy implementation of ``validate()``:

::
class MyForm extends k_Controller
{
...
  function validate($values) {
    return TRUE;
  }

By returning ``TRUE``, our form will pass, when submitted. For most forms, you'd want to do some validation before that, but for now, we'll just let it get through.

Once the validation pass, we will run into the next problem. When a form is valid -- that is, when the form is submitted, and validation passes -- a method ``validHandler()`` will be called on the context. Just like with ``validate()``, we need to provide this in our controller:

::
class MyForm extends k_Controller
{
...
  function validHandler() {
    return "validHandler called";
  }

You can now submit the form, and the text "validHandler called" should appear.

Validation
----------

So far, the validation is very forgiving, to say the least; In fact, it will always pass. To apply some real validation, we will have to implement the ``validate()`` method. In the simplest form, it returns ``TRUE`` if the form is valid, and ``FALSE`` if it isn't. To determine if the form is valid, the form field values are passed as an associative array to the method.

So a primitive validation could look like:

::
class MyForm extends k_Controller
{
...
  function validate($values) {
    return strlen($values['password']) >= 8;
  }

This will ensure that the *password* field is at least 8 characters in length.

This is fine, but when the form *doesn't* validate, we would want to provide some feedback to the user as to what is wrong. To do this, we will use a convenient helper, provided by the ``k_FormBehaviour`` class. Calling the forms ``getValidator()`` method returns an instance of ``k_Validator``. This object has a number of useful methods for validating the form.

``failField()`` logs a message on a field, and sets the state to failed. To log a failed validation on a specific field:
::
class MyForm extends k_Controller
{
...
  function validate($values) {
    $validator = $this->form->getValidator();
    if (strlen($values['password']) >= 8) {
      return TRUE;
    }
    $validator->failField('password', 'the password must be at least 8 characters in length');
    return FALSE;
  }

Alternatively, the method ``fail()`` logs a message on no specific field. Unlike its cousin, ``failField()``, it takes just one argument.

Since certain primitive validations are often repeated over again, the validator has a couple of common assertions (Methods, that validate a field). These makes it easy to add simple validation to your form:

::
class MyForm extends k_Controller
{
...
  function validate($values) {
    $validator = $this->form->getValidator();
    $validator->assertEmail('email');
    if ($validator->assertRequired('password')) {
      $validator->assertEqual('password', 'password_repeat');
    }
    return $validator->isValid();
  }

Each assertion returns the result, so you can make further validation on a field depend on previous validations. This can be observed in the example above, with the *password* field. The validator has an internal state. If an assertion fails, the state is ``FALSE``. Thus you can call the assertions needed, and return the validators state at the end.

Fine tuning
-----------

In the above template, the opening HTML ``<form>`` tag is printed like:

::
<form <?php echo $this->getFormProperties(); ?>>

The method ``getFormProperties()`` returns the attributes for the form tag. If you want to control these from the controller, you can set them through the ``$properties`` array. In particular, you would want to change the ``enctype`` key to ``multipart/form-data``, if your form contains a file-upload control. Otherwise, the defaults are probably best left be.

After a forms ``validHandler()`` has been called, the memory will normally be wiped clean. If for some reason, you want the form to retain its values, even after it has been processed, you can set the property ``$autoDestroy`` to ``FALSE``. One situation where you could use this, is in multipage forms (Sometime called wizards).

